{
  "Logging": {
    "LogLevel": {
      "Default": "Error",
      "Microsoft": "Error",
      "Microsoft.Hosting.Lifetime": "Error"
    }
  },
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "override": {
        "System": "Warning",
        "Microsoft": "Error",
        "Microsoft.Hosting.Lifetime": "Error",
        "Kafka.Connect.Plugin.Logging.SinkLog": "Information"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "formatter": "Serilog.Formatting.Json.JsonFormatter, Serilog"
        }
      }
    ],
    "Enrich": [
      "FromLogContext"
    ]
  },
  "AllowedHosts": "*",
  "worker": {
    "trace": false,
    "allowAutoCreateTopics": false,
    "bootstrapServers": "localhost:9092",
    "securityProtocol": "PlainText",
    "sslCaLocation": "",
    "sslCertificateLocation": "",
    "sslKeyLocation": "",
    "sslKeyPassword": "",
    "enableAutoCommit": true,
    "enableAutoOffsetStore": false,
    "enablePartitionEof": true,
    "fetchWaitMaxMs": 50,
    "partitionAssignmentStrategy": "RoundRobin",
    "autoOffsetReset": "earliest",
    "isolationLevel": "ReadUncommitted",
    "topics": {
      "config": "connector-config-topic",
      "status": "not-required-as-yet",
      "command": {"name":  "command-central-worker", "topic": "test-events-testing-source-3"},
      "stats": "may-be-for-future"
    },
    "schemaRegistry": {
      "connectionTimeoutMs": 5000,
      "maxCachedSchemas": 10,
      "url": "http://localhost:28081"
    },
    "healthCheck": {
      "disabled": true,
      "initialDelayMs": 10000,
      "periodicDelayMs": 50000
    },
    "failOver": {
      "disabled": false,
      "failureThreshold": 3,
      "initialDelayMs": 600,
      "periodicDelayMs": 20000,
      "restartDelayMs": 20000
    },
    "restarts": {
      "enabled": "Worker,Connector",
      "attempts": 5,
      "periodicDelayMs": 500,
      "stopOnFailure": true
    },
    "batches": {
      "size": 100,
      "parallelism": 1,
      "eofSignal": {
        "enabled": true,
        "topic": ""
      },
      "converters": {
        "key": "Kafka.Connect.Converters.JsonConverter",
        "value": "Kafka.Connect.Converters.JsonConverter"
      }
    },
    "retries": {
      "attempts": 3,
      "delayTimeoutMs": 1000,
      "errors": {
        "tolerance": "None",
        "topic": "aaaa"
      }
    },
    "plugins": {
      "location": "/Users/picardro/Github/external/roshan-picardo/kafka-connect-dotnet/plugins/",
      "initializers": {
        "default-mongodb": {
          "prefix": "mongodb",
          "assembly": "Kafka.Connect.MongoDb.dll",
          "class": "Kafka.Connect.MongoDb.Collections.DefaultPluginInitializer"
        },
        "default-postgres": {
          "prefix": "postgres",
          "assembly": "Kafka.Connect.Postgres.dll",
          "class": "Kafka.Connect.Postgres.DefaultPluginInitializer"
        }
      }
    },
    "settings": "/Users/picardro/Github/external/roshan-picardo/kafka-connect-dotnet/settings/",
    "connectors": {
      "loc-entitlements-consent-sink-connector-x": {
        "type": "source",
        "name": "loc-entitlements-consent-sink-connector-md",
        "groupId": "loc-entitlements-consent-sink-connector-md-attempt#31",
        "plugin": "default-mongodb",
        "topics": [
          "test-events-testing-source-3"
        ],
        "batches": {},
        "retries": {},
        "maxTasks": 1,
        "paused": false,
        "processors1": {
          "json-field": {
            "name": "Kafka.Connect.Processors.JsonTypeOverrider",
            "order": 1,
            "settings": [
              "consentRequest.relatedOperation.data"
            ]
          },
          "datetime-field": {
            "name": "Kafka.Connect.Processors.DateTimeTypeOverrider",
            "order": 2,
            "settings":{
              "modifiedDate": null
            }
          },
          "cif-locate": {
            "name": "Entitlements.Consent.Sink.Connector.Processors.CustomerIdLocator",
            "order": 6,
            "settings": {
              "number": 1,
              "text": "hi-hello"

            }
          },
          "whitelist": {
            "name": "Kafka.Connect.Processors.WhitelistFieldProjector",
            "order": 4,
            "settings":   [
              "consentId",
              "consentType",
              "status",
              "consentLifeTimeExpiryDate",
              "actionType",
              "customerId",
              "dependsOnConsent.consentId",
              "consentRequest.relatedOperation.data.clientId",
              "consentRequest.relatedOperation.data.scopes[*]",
              "consentRequest.relatedOperation.data.accountNumber",
              "consentRequest.relatedOperation.data.externalAccountId",
              "consentRequest.relatedOperation.data.productCode",
              "consentRequest.relatedOperation.data.accountNumberHash",
              "consentRequest.relatedOperation.data.accountOwnerCifCode",
              "consentRequest.relatedOperation.data.profileCifCode",
              "consentRequest.relatedOperation.data.profileType",
              "consentRequest.relatedOperation.data.electionType",
              "consentRequest.relatedOperation.data.providerId",
              "involvedUsers[*]",
              "modifiedDate",
              "brandCode",
              "consentRequest.relatedOperation.data.accountId",
              "consentRequest.relatedOperation.data.accountOwnerGroupCustomerUuid",
              "consentRequest.relatedOperation.data.profileGroupCustomerUuid",
              "consentRequest.relatedOperation.data.customerId"
            ]
          },
          "rename": {
            "name": "Kafka.Connect.Processors.FieldRenamer",
            "order": 5,
            "settings": {
              "consentRequest.relatedOperation.data.clientId": "clientId",
              "consentLifeTimeExpiryDate": "expiryDate",
              "consentRequest.relatedOperation.data.scopes[*]": "scopes[*]",
              "consentRequest.relatedOperation.data.accountNumber": "internalAccountNumber",
              "consentRequest.relatedOperation.data.externalAccountId": "externalAccountNumber",
              "consentRequest.relatedOperation.data.productCode": "productType",
              "consentRequest.relatedOperation.data.accountNumberHash": "accountNumberHash",
              "dependsOnConsent.consentId": "dependsOnConsentId",
              "consentRequest.relatedOperation.data.accountOwnerCifCode": "accountOwnerCifCode",
              "consentRequest.relatedOperation.data.profileCifCode": "profileCifCode",
              "consentRequest.relatedOperation.data.profileType": "profileType",
              "consentRequest.relatedOperation.data.electionType": "electionType",
              "consentRequest.relatedOperation.data.providerId": "providerId",
              "modifiedDate": "timestamp",
              "consentRequest.relatedOperation.data.accountId": "internalAccountId",
              "consentRequest.relatedOperation.data.accountOwnerGroupCustomerUuid": "accountOwnerCustomerUuid",
              "consentRequest.relatedOperation.data.profileGroupCustomerUuid": "profileCustomerUuid"
            }
          }
        },
        "sink": {
          "handler": "Kafka.Connect.MongoDb.MongoSinkHandler",
          "strategy": {
            "name": "Kafka.Connect.MongoDb.Strategies.DefaultWriteStrategy"
          },
          "properties": {
            "connectionUri": "mongodb://localhost:27017",
            "database": "entitlements",
            "collection": "consent"
          }
        },
        "source": {
          "handler": "Kafka.Connect.MongoDb.MongoSourceHandler",
          "strategy": {
            "name": "Kafka.Connect.MongoDb.Strategies.ReadStrategy"
          },
          "timeOutInMs": 5000,
          "batchSize": 100,
          "properties":{
            "connectionUri": "mongodb://localhost:27017",
            "database": "entitlements",
            "commands": {
              "customers-data-topic": {
                "topic": "test-events-testing",
                "timestampColumn": "updated",
                "collection": "customers",
                "keyColumns": ["name" ]
              }
            }
          }
        },
        "log": {
          "provider": "",
          "attributes": [
            "consentId",
            "clientId",
            "not_exists"
          ]
        }
      },
      "loc-entitlements-consent-sink-connector-pg1": {
        "batches": "",
        "groupId": "loc-entitlements-consent-sink-connector-pg-attempt#25",
        "log": {
          "attributes": [
            "consentId",
            "consentType",
            "dob-2"
          ],
          "provider": ""
        },
        "maxTasks": "4",
        "name": "loc-entitlements-consent-sink-connector-pg1",
        "paused": "True",
        "plugin": "default-postgres",
        "processors": {
          "cif-locate": {
            "name": "Entitlements.Consent.Sink.Connector.Processors.CustomerIdLocator",
            "order": "6",
            "settings": {
              "number": "1",
              "text": "hi-hello"
            }
          },
          "datetime-field": {
            "name": "Kafka.Connect.Processors.DateTimeTypeOverrider",
            "order": "2",
            "settings": {
              "modifiedDate": ""
            }
          },
          "json-field": {
            "name": "Kafka.Connect.Processors.JsonTypeOverrider",
            "order": "1",
            "settings": [
              "consentRequest.relatedOperation.data"
            ]
          },
          "rename": {
            "name": "Kafka.Connect.Processors.FieldRenamer",
            "order": "5",
            "settings": {
              "consentLifeTimeExpiryDate": "expiryDate"
            }
          },
          "whitelist": {
            "name": "Kafka.Connect.Processors.WhitelistFieldProjector",
            "order": "4",
            "settings": [
              "consentId",
              "consentType",
              "status",
              "consentLifeTimeExpiryDate",
              "actionType",
              "customerId"
            ]
          }
        },
        "retries": "",
        "sink": {
          "handler": "Kafka.Connect.Postgres.PostgresSinkHandler",
          "properties": {
            "database": "entitlements",
            "filter": {
              "condition": "\u0022consentType\u0022=\u0027{consentType}\u0027",
              "delete": {
                "allOf": {
                  "key": [
                    "value1",
                    "value2"
                  ]
                },
                "anyOf": "key/values"
              },
              "deleteIf": "",
              "keys": [
                "consentType"
              ],
              "skipIf": "",
              "upsert": {
                "if": "\u0022consentType\u0022=\u0027{0}\u0027",
                "keys": [
                  "consentType"
                ]
              }
            },
            "host": "localhost",
            "password": "postgres",
            "table": "consent",
            "userId": "postgres"
          },
          "strategy": {
            "name": "Kafka.Connect.Postgres.Strategies.UpsertStrategy"
          }
        },
        "topics": [
          "test-events-testing"
        ]
      }
    }
  }
}